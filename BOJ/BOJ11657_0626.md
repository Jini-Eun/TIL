# Baekjoon Online Judge

## algorithm practice
<br>

## - 단계별 문제풀기
<br>

## 25. 최단 경로

> 그래프의 간선에 가중치가 없으면 BFS로 최단거리를 찾을 수 있습니다. 가중치가 있다면 어떨까요?

<br>

---

<br>

**Java / Python**

<br>

### 4. 타임머신
[11657번](https://www.acmicpc.net/problem/11657) 
> 벨만 포드 알고리즘을 배우는 문제

<br>

![](https://images.velog.io/images/jini_eun/post/e6147191-c870-4d17-9bad-51803393a77f/image.png)

<br>

> 이번 문제는 1번 도시에서 출발해서 나머지 도시로 가는 가장 빠른 시간을 구하는 프로그램을 작성하는 문제입니다.
다익스트라 알고리즘(Dijkstra Algorithm)을 이용합니다.

<br><br>

- Java

<br>

```java

```


<br><br><br>

- Python 

<br><br>

```python
from heapq import heappush, heappop
import sys

# dijkstra 경로 탐색
def dijkstra(start):
    dp = [100000000 for i in range(n + 1)]
    dp[start] = 0
    heap = []
    heappush(heap, [0, start])
    while heap:
        we, nu = heappop(heap)
        for ne, nw in graph[nu]:
            wei = we + nw
            if dp[ne] > wei:
                dp[ne] = wei
                heappush(heap, [wei, ne])
    return dp

testcase = int(sys.stdin.readline())
for _ in range(testcase):
    n, m, t = map(int, sys.stdin.readline().split())
    start, g, h = map(int, sys.stdin.readline().split())
    graph = [[] for i in range(n + 1)]
    dist = []
    for j in range(m):
        a, b, d = map(int, sys.stdin.readline().split())
        graph[a].append([b, d])
        graph[b].append([a, d])
    for k in range(t):
        dist.append(int(sys.stdin.readline()))
    start_ = dijkstra(start)
    g_ = dijkstra(g)
    h_ = dijkstra(h)
    resultlist = []
    for l in dist:
        if start_[g] + g_[h] + h_[l] == start_[l] or start_[h] + h_[g] + g_[l] == start_[l]:
            resultlist.append(l)
    resultlist.sort()
    for f in resultlist:
        print(f, end=' ')
    print()
```

<br><br>

---

<br>
